---
title: "2. Data structure & cleaning"
author: "G.H. Koo"
---

## Learning goals

By the end of this tutorial, you will be able to:

- Understand vectors, data types, and data frames in R
- Convert between different data types
- Use the **tidyverse** to clean and summarize data
- Apply pipe operators to write readable R code

---

# 1.Data types in R
## Key terms: objects and data structures in R

Before working with datasets, it helps to understand a few basic terms used in R.

- **Object**  
  A general term for anything you create and store in R’s memory. For example, when you assign a value using `<-`, you are creating an object.

- **Vector**  
  A sequence of values stored in order where all elements are the same type (such as numbers or characters). Vectors are the most basic data structure in R.

- **List**  
  A container that can store multiple items of different types and lengths. Lists are flexible and can grow as needed. You can access elements by position (e.g., `mylist[[1]]`) or by name (e.g., `mylist$age`).

- **Matrix**  
  A two-dimensional structure made of rows and columns. All values in a matrix must be the same type, and its size is fixed when created.

- **Data frame**  
  A table-like structure commonly used for datasets. Each column contains one type of data, columns have names, and different columns can store different types (numeric, character, etc.).

:::callout-note
These structures form the foundation for organizing and analyzing data in R and will be used throughout the rest of the book.
:::

### 1.1 Vectors

```{r vectors}
# Vector of strings
weather <- c("windy", "cloudy", "snowy", "cold", "hot")
weather

length(weather)
weather[1]           # first element
weather[c(1, 4)]     # first and fourth elements
sort(weather)        # alphabetical order

weather[1] <- "breezy"
class(weather)

# Numeric vector
numbers <- c(7, 1, 3, 5)
sort(numbers)

# Sequence
number_seq <- 1:5
number_seq

# Logical vector
veracity <- c(TRUE, FALSE, TRUE, FALSE)
veracity
```

### 1.2 Object
```{r}
first_computer <- 1946
first_moon <- 1969
```

### 1.3 Data frames
```{r}
weather_df <- data.frame(
  day = c("Mon", "Tue", "Wed"),
  temp = c(70, 75, 80),
  snow = c(TRUE, FALSE, TRUE)
)
weather_df
```


### 1.4 List: Vectors and lists

Vector: one data type, stored in a sequence
```{r vectors-lists}

numbers <- c(1, 2, 3, 4, 5)
numbers
numbers[1:3]

fruits <- c("Apple", "Banana", "Orange")
fruits[1]
```

List: can store multiple objects of different types
```{r}
combined <- list(numbers = numbers, fruits = fruits)
combined

combined[["numbers"]]
combined[["fruits"]]

combined[["numbers"]][1:3]
combined[["fruits"]][1]
```

### 1.5 Matrices: Matrix and data frame
Matrix: one data type, arranged in rows and columns
```{r}
a <- matrix(0, nrow = 5, ncol = 5)
b <- matrix(rnorm(25), nrow = 5, ncol = 5)
```

Convert matrix to data frame
```{r}
df <- as.data.frame(b)
df[1, 5]
```

Data frame: columns can be different types (each column is one type)
```{r}
new_dataset <- mtcars
new_dataset$wt[1:5]
```

Convert a column (example)
```{r}
new_dataset$wt <- as.character(new_dataset$wt)
class(new_dataset$wt)
str(new_dataset$wt)
```

:::callout-tip
Matrices must contain a single data type. If you mix numbers and text, R will coerce everything into one type (often character). Data frames are usually more flexible for real-world datasets.
:::

### Comparing list, matrix, and data frame

```{r compare-structures}
# Data frames require columns of equal length
fruits <- c("Apple", "Banana", "Orange", 
            "Raspberry", "Strawberry")
numbers <- c(1, 2, 3, 4, 5)
df <- data.frame(numbers = numbers, fruits = fruits)
df
```

```{r}
df[1, ]
df[, 1]
df[1:3, ]
```

Matrix example: mixing numeric + character coerces to character
```{r}
numbers <- c(1, 2, 3)
fruits  <- c("Apple", "Banana", "Orange")
m <- matrix(c(numbers, fruits), nrow = 3, ncol = 2)
m
class(m)
mode(m)
```


### 1.6 Data type conversion
```{r, eval=FALSE}
x <- 5
as.character(x)  # convert to character
as.numeric(x)    # convert to numeric
as.integer(x)    # convert to integer
as.logical(x)    # convert to logical
```

```{r}
temps <- c("30", "25", "40")
class(temps)
```

Convert to numeric
```{r}
temps_num <- as.numeric(temps)
class(temps_num)
```

Check the type of an object
```{r}
variable <- "2.5"
class(variable)
```

Convert character to numeric
```{r, eval=FALSE}
numeric_variable <- as.numeric(variable)
class(numeric_variable)
numeric_variable
```

Common coercion functions
```{r, eval=FALSE}
as.numeric(3.2)
as.character(10)
as.integer("3")
```

Caution: non-numeric text becomes NA
```{r, warning=FALSE}
as.numeric("three")
```

:::callout-note
When coercion produces `NA`, it usually means the original value could not be converted.
Always check for unexpected `NA` values after converting variables.
:::

## 2. Introduction to tidyverse and the mtcars dataset

In this part of the module, we will now use mtcars, a built-in dataset from Motor Trend magazine (1974), to learn basic data cleaning and preprocessing.

::: {.callout-note}
When working with large datasets, filtering variables of interest, summarizing data, arranging, and mutating (such as to create new columns after averaging the scores) can significantly save time and memory usage in your software. We will use the 'tidyverse' package to do so. Tidyverse will automatically load packages that you’re likely to use in everyday data analyses, such as dplyr, readr, tidyr ... etc.
:::

---

# 2. Data cleaning and summarizing
### 2.1 Take a first look at the data

```{r, warning=FALSE, message=FALSE}
# install.packages("tidyverse") # Run once if needed
library(tidyverse)
data(mtcars) # Load a sample dataset
?mtcars # To learn more about the dataset
```

Check the first few rows: Use head() function to check the first few rows of the dataset, and View() to open the dataset

```{r, eval=FALSE}
head(mtcars) 
View(mtcars)
```


### 2.2 Pipe operators: `|>`, `%>%`

::: {.callout-tip} 
In R version 4.1 and later, the base pipe operator |> works the same way as %>%.
The difference is that |> is built directly into R, so you do not need to install or load dplyr to use it.

You can turn |> on through Tools > Global Options.
:::

Basic code (without pipe operator) 
```{r Tip: Using pipe operators}
mean(c(1, 2, 3, 4)) # mean(): we get the mean score. 
```

::: {.callout-note} 
Bonus: If we do not use c(), R will treat the numbers as separate function inputs instead of data values. Try: mean(1, 2, 3, 4) and check its result
:::

```{r}
mean(1, 2, 3, 4)
```

#### Using |> (basic pipe) 
It takes the result of one command and passes it into the next command.
```{r}
c(1, 2, 3, 4) |> mean()
```


#### Using %>% 
It works almost the same way as |> but requires installing and loading packages.
```{r}
library(tidyverse)
c(1, 2, 3, 4) %>% mean()
```

Pipe operators are useful for longer code because they reduce repetition, improve readability, simplify debugging and modification, and avoid creating temporary variables (more examples below).



### 2.3 Data cleaning 
We will use the select(), filter(), mutate(), arrange(), and summarize() functions.
You are also encouraged to use pipe operators.

#### Example 1: Select specific columns (Useful when you have a huge dataset).

Three options (with/without pipe operators):

1) Without pipe operator: 

Select three columns from the mtcars dataset
```{r, results="hide"}
select(mtcars, mpg, hp, wt) 
```
If you want to the first few rows of specific columns:
```{r}
head(select(mtcars, mpg, hp, wt)) 
```

2) With base pipe |>
```{r}
mtcars |>
  select(mpg, hp, wt) |>
  head()
```

3) With %>%
```{r}
mtcars %>%
  select(mpg, hp, wt) %>% # Select three columns 
  head() # View the first few rows
```


#### Example 2: Filter rows where Miles/gallon (mpg) is greater than 30

```{r, eval=FALSE}
mtcars |> 
  filter(mpg > 30)
```

You can also create a new filtered dataframe 'new_mtcars'
```{r, eval=FALSE}
new_mtcars <- mtcars |> 
  filter(mpg > 30)
```

#### Example 3: Mutate (Create a new column) that shows TRUE if mpg is over 30, or FALSE otherwise

```{r, eval=FALSE}
mtcars |>
  mutate(mpg_over_30 = ifelse(mpg > 30, TRUE, FALSE))
```

#### Example 4: Arrange data by horsepower (hp) in descending order

```{r, eval=FALSE}
mtcars |> 
  arrange(desc(hp))
```

#### Example 5: Summarize data to get the average (mean) mpg and hp

```{r, eval=FALSE}
mtcars |>
  summarize(
    avg_mpg = mean(mpg),
    avg_hp = mean(hp)
    )
```



# 3. Practice: Working with HDSinRdata

::: {.callout-note}
In this practice question, I will demonstrate how to clean and work with datasets from the HDSinRdata package. HDSinRdata package includes ten datasets used in the chapters and exercises of Paul, Alice (2023) "Health Data Science in R" https://alicepaul.github.io/health-data-science-using-r/.

After we call the HDSinRdata package, we will use 'covidcases' and 'mobility' data from the package. 
:::


```{r, warning=FALSE, message=FALSE}
#install.packages("HDSinRdata")
library(HDSinRdata) 
```

```{r}
data(covidcases) 
data(mobility)
```

Displays the first few lines of the dataset.
Or you can specify the number of lines to view; here, it shows '5'
```{r, eval=FALSE}
head(mobility) 
head(mobility, n = 5) 
```

Displays median, mean, min/max ... etc
```{r}
summary(mobility) 
```

### Pre-processing the data (select and summarize)

Check the names of the columns
```{r, eval=FALSE}
colnames(covidcases)
colnames(mobility)
```


Display the frequency of unique values in the 'state' column
```{r, eval=FALSE}
table(covidcases$state)
table(mobility$state)
```

Filter rows where the 'state' column is 'Hawaii' You could directly filter it or create a new dataframe with the filtered rows (recommended)

Directly filter:
```{r}
covidcases |> 
  filter(state == "Hawaii")
```

Create a new dataframe:
```{r}
hawaii_covidcases <- covidcases |>
  filter(state == "Hawaii")
```
```{r, eval=FALSE}
print(hawaii_covidcases)
```

```{r}
hawaii_mobility <- mobility |>
  filter(state == "Hawaii")
```
```{r, eval=FALSE}
print(hawaii_mobility)
```

You can also use nrow() to count how many rows there are (in filtered dataset)

```{r}
nrow(hawaii_covidcases)  
nrow(hawaii_mobility)
```

---

## Summary: 

In this chapter, you learned how to work with core R structures such as vectors, data frames, objects, lists, and matrices. You also practiced converting between data types, using pipe operators to write clear and readable code, and cleaning and summarizing real-world datasets. These foundational skills prepare you to move from data preparation to analysis. In the next chapter, we will build on these concepts to explore data visualization and interpretation.